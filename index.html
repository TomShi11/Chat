<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>11s Chat</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ“œ</text></svg>">
    
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">

    <style>
        :root {
            --bg-paper: #fdf6e3; --bg-sidebar: #f5eacb; --bg-accent: #d4c5a3;     
            --text-main: #4a3b2a; --text-light: #8b7e74; --border: #dcd3c1;
            --msg-sent: #eaddcf; --msg-received: #ffffff;  
            --btn-primary: #5b4636; --btn-hover: #423226; --radius: 12px;
            --danger: #ef4444;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { background-color: var(--bg-paper); color: var(--text-main); font-family: "Georgia", "Songti SC", serif; height: 100vh; display: flex; justify-content: center; align-items: center; overflow: hidden; }
        #app { width: 100%; height: 100%; display: flex; }

        /* ä¾§è¾¹æ  */
        .sidebar { width: 280px; background-color: var(--bg-sidebar); border-right: 1px solid var(--border); display: flex; flex-direction: column; padding: 24px; z-index: 10; }
        .brand { font-size: 22px; font-weight: bold; margin-bottom: 30px; display: flex; align-items: center; gap: 10px; }
        .conn-status { width: 10px; height: 10px; border-radius: 50%; background: #ccc; display: inline-block; margin-left: auto; transition: 0.3s; }
        .conn-status.online { background: #34c759; box-shadow: 0 0 5px #34c759; }
        
        .friend-list { flex: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 6px; }
        .friend-item { padding: 12px; border-radius: var(--radius); cursor: pointer; transition: 0.2s; display: flex; align-items: center; gap: 12px; border: 1px solid transparent; position: relative; }
        .friend-item:hover { background-color: rgba(255,255,255,0.5); }
        .friend-item.active { background-color: #fff; border-color: var(--border); box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
        .avatar { width: 40px; height: 40px; background: var(--bg-accent); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; color: #fff; text-transform: uppercase; font-size: 16px; flex-shrink: 0; }
        .friend-info { flex: 1; min-width: 0; }
        .friend-name { font-weight: bold; font-size: 15px; margin-bottom: 2px; }
        .friend-preview { font-size: 12px; color: var(--text-light); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        
        /* çº¢ç‚¹ */
        .unread-badge { background: var(--danger); color: white; font-size: 10px; min-width: 18px; height: 18px; border-radius: 9px; display: flex; align-items: center; justify-content: center; padding: 0 5px; font-weight: bold; box-shadow: 0 2px 4px rgba(239,68,68,0.3); }

        .user-info { margin-top: auto; padding-top: 20px; border-top: 1px solid rgba(0,0,0,0.06); display: flex; align-items: center; gap: 12px; }

        /* èŠå¤©åŒº */
        .main-chat { flex: 1; display: flex; flex-direction: column; background-image: radial-gradient(#dccdb3 1px, transparent 1px); background-size: 24px 24px; position: relative; }
        .chat-header { padding: 18px 30px; border-bottom: 1px solid var(--border); font-size: 18px; font-weight: bold; background: rgba(253, 246, 227, 0.95); backdrop-filter: blur(10px); display: flex; align-items: center; gap: 10px; z-index: 20; }
        .chat-messages { flex: 1; overflow-y: auto; padding: 30px; display: flex; flex-direction: column; gap: 16px; scroll-behavior: smooth; }
        
        /* æ¶ˆæ¯æ°”æ³¡ & åŠ¨ç”» */
        .message-row { display: flex; flex-direction: column; max-width: 70%; position: relative; animation: slideUp 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .message-row.sent { align-self: flex-end; align-items: flex-end; }
        .message-row.received { align-self: flex-start; align-items: flex-start; }
        
        @keyframes slideUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        .message-bubble { padding: 12px 16px; border-radius: 16px; font-size: 15px; line-height: 1.5; box-shadow: 2px 2px 6px rgba(0,0,0,0.03); word-wrap: break-word; position: relative; cursor: context-menu; transition: background 0.2s; }
        .message-bubble.sent { background-color: var(--msg-sent); border-bottom-right-radius: 2px; }
        .message-bubble.received { background-color: var(--msg-received); border-bottom-left-radius: 2px; }
        .message-bubble.recalled { background: rgba(0,0,0,0.05); color: #999; font-style: italic; font-size: 13px; padding: 8px 12px; box-shadow: none; cursor: default; }

        /* å†…å®¹ç±»å‹æ ·å¼ */
        .msg-img { max-width: 200px; max-height: 200px; border-radius: 8px; cursor: zoom-in; display: block; }
        .msg-file { display: flex; align-items: center; gap: 10px; background: rgba(0,0,0,0.05); padding: 8px 12px; border-radius: 8px; text-decoration: none; color: var(--text-main); font-size: 14px; }
        .msg-file i { font-size: 20px; }
        .msg-voice { display: flex; align-items: center; gap: 8px; cursor: pointer; min-width: 80px; }
        
        .msg-meta { font-size: 10px; opacity: 0.5; margin-top: 4px; display: flex; gap: 6px; align-items: center; }
        .read-status { font-weight: bold; color: var(--btn-primary); }

        /* å³é”®èœå• */
        .context-menu { position: fixed; background: #fff; border: 1px solid var(--border); border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.1); padding: 5px 0; z-index: 1000; min-width: 100px; }
        .menu-item { padding: 8px 16px; font-size: 14px; cursor: pointer; display: flex; align-items: center; gap: 8px; color: var(--text-main); }
        .menu-item:hover { background: var(--bg-paper); }
        .menu-item.danger { color: var(--danger); }

        /* è¾“å…¥åŒº */
        .chat-input-area { padding: 15px 20px; border-top: 1px solid var(--border); background: rgba(253, 246, 227, 0.95); display: flex; gap: 10px; align-items: flex-end; }
        .toolbar-btn { background: transparent; border: none; color: var(--text-light); font-size: 20px; cursor: pointer; padding: 8px; border-radius: 50%; transition: 0.2s; flex-shrink: 0; }
        .toolbar-btn:hover, .toolbar-btn.active { background: rgba(0,0,0,0.05); color: var(--text-main); }
        .toolbar-btn.recording { color: var(--danger); animation: pulse 1s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
        
        .input-box { flex: 1; border: 1px solid var(--border); background: #fff; padding: 12px 16px; border-radius: 20px; font-size: 15px; outline: none; resize: none; height: 46px; line-height: 20px; max-height: 120px; }
        .input-box:focus { border-color: var(--text-light); box-shadow: 0 0 0 3px rgba(91, 70, 54, 0.05); }
        .send-btn { background: var(--btn-primary); color: #fff; border: none; width: 46px; height: 46px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 18px; flex-shrink: 0; transition: 0.2s; }
        .send-btn:hover { transform: scale(1.05); }

        /* é™„ä»¶/è¡¨æƒ… é¢æ¿ */
        .panel-popover { position: absolute; bottom: 80px; left: 20px; background: #fff; border: 1px solid var(--border); border-radius: 12px; padding: 10px; box-shadow: 0 5px 20px rgba(0,0,0,0.1); z-index: 50; }
        .emoji-grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; width: 280px; height: 200px; overflow-y: auto; }
        .emoji-item { font-size: 24px; cursor: pointer; text-align: center; padding: 5px; border-radius: 4px; }
        .emoji-item:hover { background: #f0f0f0; }

        /* å¤§å›¾é¢„è§ˆ */
        .img-preview-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 2000; display: flex; justify-content: center; align-items: center; cursor: zoom-out; }
        .img-preview { max-width: 90%; max-height: 90%; border-radius: 8px; box-shadow: 0 0 30px rgba(0,0,0,0.5); }

        /* ç™»å½•å¼¹çª— */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(74, 59, 42, 0.4); backdrop-filter: blur(4px); display: flex; justify-content: center; align-items: center; z-index: 100; }
        .modal-card { background: #fffbf0; padding: 40px; width: 360px; border-radius: 16px; box-shadow: 0 20px 40px rgba(91, 70, 54, 0.2); text-align: center; border: 1px solid var(--border); }
        .modal-input { width: 100%; padding: 12px 14px; margin-bottom: 12px; border: 1px solid var(--border); border-radius: 8px; font-size: 15px; outline: none; background: #fff; }
        .modal-btn { width: 100%; margin-top: 10px; padding: 12px; background: var(--btn-primary); color: #fff; border: none; border-radius: 8px; cursor: pointer; font-size: 15px; font-weight: bold; }
        .modal-btn:disabled { opacity: 0.7; cursor: not-allowed; }
        .error-msg { color: #dc2626; font-size: 13px; margin-top: 15px; }
        .empty-state { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; opacity: 0.4; }
    </style>
</head>
<body>

<div id="app" @click="closeMenus">
    <!-- å¤§å›¾é¢„è§ˆ -->
    <div class="img-preview-overlay" v-if="previewImg" @click="previewImg = null">
        <img :src="previewImg" class="img-preview">
    </div>

    <!-- å³é”®èœå• -->
    <div class="context-menu" v-if="contextMenu.visible" :style="{ top: contextMenu.y + 'px', left: contextMenu.x + 'px' }" @click.stop>
        <div class="menu-item" v-if="canRecall" @click="recallMessage"><i class="bi bi-arrow-counterclockwise"></i> æ’¤å›</div>
        <div class="menu-item danger" @click="deleteMessage"><i class="bi bi-trash"></i> åˆ é™¤(æœ¬åœ°)</div>
    </div>

    <!-- ç™»å½•/æ³¨å†Œ -->
    <div class="modal-overlay" v-if="!currentUser">
        <div class="modal-card">
            <h2 style="margin-bottom: 10px; color: var(--text-main);">11s Chat</h2>
            <p style="margin-bottom: 20px; font-size: 14px; opacity: 0.7;">{{ isRegistering ? 'åˆ›å»ºæ–°è´¦å·' : 'ç™»å½•ä½ çš„è´¦å·' }}</p>
            <input type="text" class="modal-input" v-model="loginForm.username" placeholder="ç”¨æˆ·å" @keyup.enter="handleLogin">
            <input type="password" class="modal-input" v-model="loginForm.password" placeholder="å¯†ç " @keyup.enter="handleLogin">
            <button class="modal-btn" @click="handleLogin" :disabled="isLoading">{{ isLoading ? 'å¤„ç†ä¸­...' : (isRegistering ? 'æ³¨å†Œ' : 'ç™»å½•') }}</button>
            <div class="error-msg">{{ errorMessage }}</div>
            <div style="margin-top: 15px; font-size: 12px; color: #888; cursor: pointer;" @click="toggleMode">{{ isRegistering ? 'å·²æœ‰è´¦å·ï¼Ÿå»ç™»å½•' : 'æ²¡æœ‰è´¦å·ï¼Ÿå»æ³¨å†Œ' }}</div>
        </div>
    </div>

    <!-- ä¸»ç•Œé¢ -->
    <template v-if="currentUser">
        <div class="sidebar">
            <div class="brand">
                <span><i class="bi bi-feather"></i> 11s Chat</span>
                <span class="conn-status" :class="{ online: isConnected }" :title="isConnected?'Online':'Connecting...'"></span>
            </div>
            <div class="section-title">è”ç³»äºº <i class="bi bi-plus-circle-fill add-btn" @click="addFriendPrompt"></i></div>
            
            <div class="friend-list">
                <div v-for="friend in friends" :key="friend.id" class="friend-item" :class="{ active: currentChat?.id === friend.id }" @click="selectChat(friend)">
                    <div class="avatar">{{ friend.username.substring(0,1) }}</div>
                    <div class="friend-info">
                        <div class="friend-name">{{ friend.username }}</div>
                        <div class="friend-preview" v-if="friend.lastMsg">
                            {{ friend.lastMsg.is_recalled ? 'æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯' : (friend.lastMsg.msg_type === 'text' ? friend.lastMsg.content : '['+friend.lastMsg.msg_type+']') }}
                        </div>
                    </div>
                    <div class="unread-badge" v-if="friend.unread > 0">{{ friend.unread }}</div>
                </div>
            </div>
            
            <div class="user-info">
                <div class="avatar" style="background:var(--text-main)">{{ currentUser.username.substring(0,1) }}</div>
                <div style="flex:1; font-weight:bold;">{{ currentUser.username }}</div>
                <div style="font-size:11px; cursor:pointer; opacity:0.6;" @click="logout">é€€å‡º</div>
            </div>
        </div>

        <div class="main-chat">
            <template v-if="currentChat">
                <div class="chat-header">
                    <span>{{ currentChat.username }}</span>
                </div>
                
                <div class="chat-messages" id="msg-container">
                    <div v-for="msg in messages" :key="msg.id" class="message-row" :class="msg.sender_id === currentUser.id ? 'sent' : 'received'">
                        <div class="message-bubble" 
                             :class="[msg.sender_id === currentUser.id ? 'sent' : 'received', { recalled: msg.is_recalled }]"
                             @contextmenu.prevent="showContextMenu($event, msg)">
                            
                            <template v-if="msg.is_recalled">
                                <i class="bi bi-arrow-counterclockwise"></i> æ¶ˆæ¯å·²æ’¤å›
                            </template>
                            
                            <template v-else>
                                <!-- æ–‡æœ¬ -->
                                <div v-if="msg.msg_type === 'text'">{{ msg.content }}</div>
                                <!-- å›¾ç‰‡ -->
                                <img v-else-if="msg.msg_type === 'image'" :src="msg.file_url" class="msg-img" @click="previewImg = msg.file_url">
                                <!-- æ–‡ä»¶ -->
                                <a v-else-if="msg.msg_type === 'file'" :href="msg.file_url" target="_blank" class="msg-file">
                                    <i class="bi bi-file-earmark-text"></i> {{ msg.file_name || 'é™„ä»¶' }}
                                </a>
                                <!-- è¯­éŸ³ -->
                                <div v-else-if="msg.msg_type === 'voice'" class="msg-voice" @click="playVoice(msg.file_url)">
                                    <i class="bi bi-mic-fill"></i> è¯­éŸ³æ¶ˆæ¯
                                    <audio :src="msg.file_url" style="display:none"></audio>
                                </div>
                            </template>
                        </div>
                        <div class="msg-meta" v-if="!msg.is_recalled">
                            <span v-if="msg.sender_id === currentUser.id && msg.is_read" class="read-status">å·²è¯»</span>
                            <span>{{ formatTime(msg.created_at) }}</span>
                        </div>
                    </div>
                </div>
                
                <div class="chat-input-area">
                    <!-- é™„ä»¶ -->
                    <button class="toolbar-btn" @click="triggerFileUpload" title="å‘é€æ–‡ä»¶/å›¾ç‰‡">
                        <i class="bi bi-paperclip"></i>
                    </button>
                    <input type="file" id="fileInput" style="display:none" @change="handleFileUpload">

                    <!-- è¯­éŸ³ -->
                    <button class="toolbar-btn" :class="{ recording: isRecording, active: isRecording }" @mousedown="startRecord" @mouseup="stopRecord" @mouseleave="stopRecord" title="æŒ‰ä½è¯´è¯">
                        <i class="bi bi-mic"></i>
                    </button>

                    <!-- è¡¨æƒ… -->
                    <button class="toolbar-btn" @click.stop="showEmoji = !showEmoji" title="è¡¨æƒ…">
                        <i class="bi bi-emoji-smile"></i>
                    </button>
                    <div class="panel-popover" v-if="showEmoji" @click.stop>
                        <div class="emoji-grid">
                            <div class="emoji-item" v-for="em in emojis" @click="addEmoji(em)">{{ em }}</div>
                        </div>
                    </div>

                    <input type="text" class="input-box" v-model="newMessage" placeholder="å†™ä¿¡..." @keyup.enter="sendMessage" @focus="markAsRead">
                    <button class="send-btn" @click="sendMessage"><i class="bi bi-send-fill"></i></button>
                </div>
            </template>
            <template v-else>
                <div class="empty-state">
                    <i class="bi bi-chat-square-quote empty-icon"></i>
                    <p>é€‰æ‹©ä¸€ä¸ªå¥½å‹å¼€å§‹èŠå¤©</p>
                </div>
            </template>
        </div>
    </template>
</div>

<script>
    const SUPABASE_URL = 'https://fznfneqwxzuwtognuoeo.supabase.co'; 
    const SUPABASE_KEY = 'sb_publishable_UlNMDLt4OaYIX-_lCezGwA_8jIQLhFO'; 
    
    const sb = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
    const { createApp, ref, onMounted, nextTick, onUnmounted, computed } = Vue;
    const EMOJIS = ['ğŸ˜€','ğŸ˜‚','ğŸ¥°','ğŸ˜','ğŸ¤”','ğŸ˜¡','ğŸ˜­','ğŸ‘','ğŸ¤','ğŸ‰','ğŸ”¥','â¤ï¸','ğŸ“œ','ğŸ–Šï¸','â˜•','ğŸº','ğŸ•','ğŸ±','ğŸ¶','ğŸ¸','ğŸ‘»','ğŸ‘½','ğŸ¤–','ğŸ’©'];

    createApp({
        setup() {
            // State
            const currentUser = ref(null);
            const loginForm = ref({ username: '', password: '' });
            const isRegistering = ref(false);
            const isLoading = ref(false);
            const errorMessage = ref('');
            const friends = ref([]);
            const currentChat = ref(null);
            const messages = ref([]);
            const newMessage = ref('');
            const isConnected = ref(false);
            const showEmoji = ref(false);
            const previewImg = ref(null);
            const contextMenu = ref({ visible: false, x: 0, y: 0, msg: null });
            const isRecording = ref(false);
            let mediaRecorder = null;
            let audioChunks = [];
            let pollingInterval = null;

            // Notification
            if (Notification.permission === 'default') Notification.requestPermission();

            onMounted(() => {
                const saved = localStorage.getItem('11s_user');
                if (saved) { currentUser.value = JSON.parse(saved); loadFriends(); startPolling(); setupRealtime(); }
            });

            onUnmounted(() => {
                if (pollingInterval) clearInterval(pollingInterval);
            });

            // --- æ ¸å¿ƒé€»è¾‘ ---

            const loadFriends = async () => {
                // 1. è·å–å¥½å‹åˆ—è¡¨
                const { data: f1 } = await sb.from('chat_friends').select('friend_id').eq('user_id', currentUser.value.id);
                const { data: f2 } = await sb.from('chat_friends').select('user_id').eq('friend_id', currentUser.value.id);
                const ids = [...new Set([...(f1||[]).map(f => f.friend_id), ...(f2||[]).map(f => f.user_id)])];

                if (ids.length > 0) {
                    const { data: users } = await sb.from('chat_users').select('*').in('id', ids);
                    // åˆå§‹åŒ–æœªè¯»çŠ¶æ€
                    friends.value = users.map(u => ({ ...u, unread: 0, lastMsg: null }));
                    fetchUnreadCounts();
                }
            };

            const fetchUnreadCounts = async () => {
                // è·å–æ¯ä¸ªå¥½å‹çš„æœ€åä¸€æ¡æ¶ˆæ¯å’Œæœªè¯»æ•° (ç®€åŒ–ç‰ˆï¼šæ‹‰å–æ‰€æœ‰æœªè¯»)
                const { data } = await sb.from('chat_messages')
                    .select('sender_id, content, msg_type, is_recalled, is_read')
                    .eq('receiver_id', currentUser.value.id)
                    .eq('is_read', false);
                
                if(data) {
                    data.forEach(msg => {
                        const friend = friends.value.find(f => f.id === msg.sender_id);
                        if(friend) friend.unread++;
                    });
                }
            };

            const selectChat = async (friend) => {
                currentChat.value = friend;
                friend.unread = 0; // æ¸…é™¤çº¢ç‚¹
                await loadMessages();
                markAsRead(); // æ ‡è®°å·²è¯»
            };

            const loadMessages = async () => {
                if (!currentChat.value) return;
                const { data } = await sb.from('chat_messages')
                    .select('*')
                    .or(`sender_id.eq.${currentUser.value.id},receiver_id.eq.${currentUser.value.id}`)
                    .order('created_at', { ascending: true });
                
                messages.value = (data || []).filter(m => 
                    (m.sender_id === currentUser.value.id && m.receiver_id === currentChat.value.id) ||
                    (m.sender_id === currentChat.value.id && m.receiver_id === currentUser.value.id)
                );
                scrollToBottom();
            };

            const startPolling = () => {
                if (pollingInterval) clearInterval(pollingInterval);
                pollingInterval = setInterval(() => { 
                    if (currentChat.value) loadMessages(); 
                    fetchUnreadCounts(); // æ›´æ–°çº¢ç‚¹
                }, 3000);
            };

            const sendMessage = async () => {
                if (!newMessage.value.trim() && !newMessage.value.startsWith('img::')) return;
                const content = newMessage.value;
                newMessage.value = '';
                showEmoji.value = false;
                
                // ä¹è§‚æ›´æ–°
                const tempMsg = { id: Date.now(), sender_id: currentUser.value.id, receiver_id: currentChat.value.id, content: content, msg_type: 'text', created_at: new Date().toISOString() };
                messages.value.push(tempMsg);
                scrollToBottom();

                await sb.from('chat_messages').insert({
                    sender_id: currentUser.value.id,
                    receiver_id: currentChat.value.id,
                    content: content,
                    msg_type: 'text'
                });
            };

            const markAsRead = async () => {
                if(!currentChat.value) return;
                // æ›´æ–°æ•°æ®åº“
                await sb.from('chat_messages')
                    .update({ is_read: true })
                    .eq('sender_id', currentChat.value.id)
                    .eq('receiver_id', currentUser.value.id)
                    .eq('is_read', false);
            };

            // --- å®æ—¶ç³»ç»Ÿ ---
            const setupRealtime = () => {
                sb.removeAllChannels();
                sb.channel('public:chat_messages')
                .on('postgres_changes', { event: '*', schema: 'public', table: 'chat_messages' }, payload => {
                    const msg = payload.new || payload.old; // UPDATE/DELETE ç”¨ new
                    const event = payload.eventType;

                    // 1. å¤„ç†æ–°æ¶ˆæ¯ (INSERT)
                    if (event === 'INSERT') {
                        // å¦‚æœæ˜¯å½“å‰èŠå¤©
                        if (currentChat.value && 
                            ((msg.sender_id === currentUser.value.id && msg.receiver_id === currentChat.value.id) ||
                             (msg.sender_id === currentChat.value.id && msg.receiver_id === currentUser.value.id))) {
                            
                            // å»é‡å¹¶æ·»åŠ 
                            if (!messages.value.some(m => m.id === msg.id)) {
                                messages.value.push(msg);
                                scrollToBottom();
                                if (msg.sender_id !== currentUser.value.id) markAsRead(); // ç«‹å³å·²è¯»
                            }
                        } 
                        // å¦‚æœä¸æ˜¯å½“å‰èŠå¤© -> æ˜¾ç¤ºçº¢ç‚¹ & é€šçŸ¥
                        else if (msg.receiver_id === currentUser.value.id) {
                            const sender = friends.value.find(f => f.id === msg.sender_id);
                            if (sender) {
                                sender.unread++;
                                sendBrowserNotify(sender.username, msg.content);
                            }
                        }
                    } 
                    // 2. å¤„ç†æ›´æ–° (UPDATE: å·²è¯»/æ’¤å›)
                    else if (event === 'UPDATE') {
                        // æ›´æ–°æ¶ˆæ¯åˆ—è¡¨é‡Œçš„çŠ¶æ€
                        const idx = messages.value.findIndex(m => m.id === msg.id);
                        if (idx !== -1) {
                            messages.value[idx] = msg; // æ›¿æ¢ä¸ºæœ€æ–°çŠ¶æ€
                        }
                    }
                })
                .subscribe(status => isConnected.value = status === 'SUBSCRIBED');
            };

            // --- é™„ä»¶ä¸è¯­éŸ³ ---
            const triggerFileUpload = () => document.getElementById('fileInput').click();
            const handleFileUpload = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const type = file.type.startsWith('image/') ? 'image' : 'file';
                const fileName = `${Date.now()}_${file.name}`;
                
                try {
                    const { error } = await sb.storage.from('chat-uploads').upload(fileName, file);
                    if (error) throw error;
                    const { data } = sb.storage.from('chat-uploads').getPublicUrl(fileName);

                    await sb.from('chat_messages').insert({
                        sender_id: currentUser.value.id,
                        receiver_id: currentChat.value.id,
                        msg_type: type,
                        file_url: data.publicUrl,
                        file_name: file.name,
                        content: type === 'image' ? '[å›¾ç‰‡]' : '[æ–‡ä»¶]'
                    });
                } catch(err) { alert("ä¸Šä¼ å¤±è´¥: " + err.message); }
            };

            const startRecord = async () => {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];
                    mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
                    mediaRecorder.onstop = sendVoice;
                    mediaRecorder.start();
                    isRecording.value = true;
                } catch(e) { alert("æ— æ³•è®¿é—®éº¦å…‹é£"); }
            };
            const stopRecord = () => {
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                    isRecording.value = false;
                }
            };
            const sendVoice = async () => {
                if(audioChunks.length === 0) return;
                const blob = new Blob(audioChunks, { type: 'audio/webm' });
                const fileName = `voice_${Date.now()}.webm`;
                
                const { error } = await sb.storage.from('chat-uploads').upload(fileName, blob);
                if (!error) {
                    const { data } = sb.storage.from('chat-uploads').getPublicUrl(fileName);
                    await sb.from('chat_messages').insert({
                        sender_id: currentUser.value.id,
                        receiver_id: currentChat.value.id,
                        msg_type: 'voice',
                        file_url: data.publicUrl,
                        content: '[è¯­éŸ³]'
                    });
                }
            };
            const playVoice = (url) => { new Audio(url).play(); };

            // --- æ’¤å›é€»è¾‘ ---
            const showContextMenu = (e, msg) => {
                if (msg.sender_id === currentUser.value.id && !msg.is_recalled) {
                    contextMenu.value = { visible: true, x: e.clientX, y: e.clientY, msg: msg };
                }
            };
            const closeMenus = () => { contextMenu.value.visible = false; showEmoji.value = false; };
            const canRecall = computed(() => {
                // é™åˆ¶2åˆ†é’Ÿå†…æ’¤å›
                if (!contextMenu.value.msg) return false;
                const diff = (new Date() - new Date(contextMenu.value.msg.created_at)) / 1000 / 60;
                return diff < 2; 
            });
            const recallMessage = async () => {
                const msg = contextMenu.value.msg;
                await sb.from('chat_messages').update({ is_recalled: true }).eq('id', msg.id);
                closeMenus();
            };
            const deleteMessage = () => {
                // ä»…æœ¬åœ°åˆ é™¤
                messages.value = messages.value.filter(m => m.id !== contextMenu.value.msg.id);
                closeMenus();
            };

            // --- æ‚é¡¹ ---
            const sendBrowserNotify = (user, text) => {
                if (Notification.permission === "granted" && document.hidden) {
                    new Notification(`æ¥è‡ª ${user} çš„æ–°æ¶ˆæ¯`, { body: text, icon: 'data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ“œ</text></svg>' });
                }
            };
            
            const handleLogin = async () => {
                isLoading.value = true; errorMessage.value = '';
                const { username, password } = loginForm.value;
                if (!username.trim() || !password.trim()) { errorMessage.value = "è¯·è¾“å…¥ç”¨æˆ·åå’Œå¯†ç "; isLoading.value = false; return; }
                
                const cleanUsername = username.trim();
                
                try {
                    let user;
                    if(isRegistering.value) {
                         const { data: exist } = await sb.from('chat_users').select('id').eq('username', cleanUsername).maybeSingle();
                         if(exist) throw new Error("ç”¨æˆ·åå·²å­˜åœ¨");
                         const { data: newUser, error } = await sb.from('chat_users').insert({ username: cleanUsername, password }).select().single();
                         if(error) throw error; user = newUser;
                    } else {
                         const { data, error } = await sb.from('chat_users').select('*').eq('username', cleanUsername).maybeSingle();
                         if(error || !data || data.password !== password) throw new Error("ç”¨æˆ·ä¸å­˜åœ¨æˆ–å¯†ç é”™è¯¯");
                         user = data;
                    }
                    currentUser.value = user; localStorage.setItem('11s_user', JSON.stringify(user));
                    loadFriends(); startPolling(); setupRealtime();
                } catch(e) { errorMessage.value = e.message || "ç™»å½•å¤±è´¥"; }
                isLoading.value = false;
            };
            
            const logout = () => { localStorage.removeItem('11s_user'); location.reload(); };
            const toggleMode = () => isRegistering.value = !isRegistering.value;
            const addFriendPrompt = async () => {
                const name = prompt("è¾“å…¥å¥½å‹ç”¨æˆ·å:");
                if(!name) return;
                const { data: target } = await sb.from('chat_users').select('*').eq('username', name.trim()).maybeSingle();
                if(target) {
                    if (target.id === currentUser.value.id) { alert("ä¸èƒ½æ·»åŠ è‡ªå·±"); return; }
                    await sb.from('chat_friends').insert({ user_id: currentUser.value.id, friend_id: target.id });
                    alert("æ·»åŠ æˆåŠŸ"); loadFriends();
                } else alert("ç”¨æˆ·ä¸å­˜åœ¨");
            };
            const addEmoji = (em) => newMessage.value += em;
            const scrollToBottom = () => nextTick(() => { const c = document.getElementById('msg-container'); if(c) c.scrollTop = c.scrollHeight; });
            const formatTime = (iso) => { const d = new Date(iso); return `${d.getHours().toString().padStart(2,'0')}:${d.getMinutes().toString().padStart(2,'0')}`; };

            return {
                currentUser, loginForm, isRegistering, isLoading, errorMessage, friends, currentChat, messages, newMessage,
                isConnected, showEmoji, EMOJIS, previewImg, contextMenu, canRecall, isRecording,
                handleLogin, logout, toggleMode, addFriendPrompt, selectChat, sendMessage, formatTime, 
                addEmoji, triggerFileUpload, handleFileUpload, startRecord, stopRecord, playVoice,
                showContextMenu, recallMessage, deleteMessage, closeMenus, markAsRead
            };
        }
    }).mount('#app');
</script>
</body>
</html>
