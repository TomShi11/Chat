<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, interactive-widget=resizes-content">
    <title>11s Chat</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üìú</text></svg>">
    
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">

    <style>
        :root {
            --bg-paper: #fdf6e3; --bg-sidebar: #f5eacb; --bg-accent: #d4c5a3;     
            --text-main: #4a3b2a; --text-light: #8b7e74; --border: #dcd3c1;
            --msg-sent: #eaddcf; --msg-received: #ffffff;  
            --btn-primary: #5b4636; --btn-hover: #423226; --radius: 12px;
            --danger: #ef4444; --success: #34c759;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
        
        body { 
            background-color: var(--bg-paper); color: var(--text-main); 
            font-family: "Georgia", "Songti SC", serif; 
            height: 100vh; height: 100dvh; display: flex; justify-content: center; align-items: center; overflow: hidden; 
        }
        
        #app { width: 100%; height: 100%; display: flex; position: relative; }

        /* ‰æßËæπÊ†è */
        .sidebar { width: 280px; background-color: var(--bg-sidebar); border-right: 1px solid var(--border); display: flex; flex-direction: column; padding: 24px; z-index: 10; transition: transform 0.3s ease; }
        .brand { font-size: 22px; font-weight: bold; margin-bottom: 20px; display: flex; align-items: center; gap: 10px; }
        .conn-status { width: 8px; height: 8px; border-radius: 50%; background: #ccc; margin-left: auto; }
        .conn-status.online { background: #34c759; box-shadow: 0 0 5px #34c759; }
        
        .section-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; color: var(--text-light); font-size: 12px; text-transform: uppercase; }
        .icon-btn { cursor: pointer; font-size: 18px; padding: 5px; }
        
        .friend-list { flex: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 6px; }
        .friend-item { padding: 12px; border-radius: var(--radius); cursor: pointer; display: flex; align-items: center; gap: 12px; position: relative; }
        .friend-item.active { background-color: #fff; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
        .avatar { width: 42px; height: 42px; background: var(--bg-accent); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; color: #fff; font-size: 16px; flex-shrink: 0; }
        .friend-info { flex: 1; min-width: 0; }
        .friend-name { font-weight: bold; font-size: 15px; margin-bottom: 4px; }
        .friend-preview { font-size: 12px; color: var(--text-light); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .unread-badge { background: var(--danger); color: white; font-size: 10px; min-width: 18px; height: 18px; border-radius: 9px; display: flex; align-items: center; justify-content: center; padding: 0 5px; font-weight: bold; }

        .user-panel { margin-top: auto; padding-top: 15px; border-top: 1px solid rgba(0,0,0,0.06); display: flex; align-items: center; gap: 12px; }
        .action-icon { font-size: 20px; cursor: pointer; color: var(--text-light); padding: 5px; margin-left: auto; }

        /* ËÅäÂ§©‰∏ªÁ™óÂè£ */
        .main-chat { flex: 1; display: flex; flex-direction: column; background-image: radial-gradient(#dccdb3 1px, transparent 1px); background-size: 24px 24px; position: relative; z-index: 5; }
        .chat-header { height: 60px; padding: 0 20px; border-bottom: 1px solid var(--border); background: rgba(253, 246, 227, 0.95); backdrop-filter: blur(10px); display: flex; align-items: center; gap: 10px; font-weight: bold; font-size: 16px; z-index: 20; }
        .back-btn { display: none; font-size: 20px; cursor: pointer; padding: 10px; margin-left: -10px; }

        .chat-messages { flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 12px; scroll-behavior: auto; }
        
        /* Ê∂àÊÅØÊ∞îÊ≥°ÂÆπÂô® */
        .message-row { display: flex; flex-direction: column; max-width: 80%; position: relative; }
        .message-row.sent { align-self: flex-end; align-items: flex-end; }
        .message-row.received { align-self: flex-start; align-items: flex-start; }

        /* Âä®Áîª TransitionGroup */
        .msg-anim-enter-active { transition: all 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28); }
        .msg-anim-enter-from { opacity: 0; transform: translateY(20px); }

        .message-bubble { padding: 10px 14px; border-radius: 16px; font-size: 15px; line-height: 1.5; box-shadow: 1px 1px 3px rgba(0,0,0,0.05); position: relative; word-wrap: break-word; }
        .message-bubble.sent { background-color: var(--msg-sent); border-bottom-right-radius: 2px; }
        .message-bubble.received { background-color: var(--msg-received); border-bottom-left-radius: 2px; }
        .message-bubble.recalled { background: rgba(0,0,0,0.03); color: #999; font-style: italic; font-size: 13px; padding: 8px 12px; box-shadow: none; }

        /* ‰øÆÂ§çÂêéÁöÑËØ≠Èü≥Êù°ÔºöÂìçÂ∫îÂºèÂÆΩÂ∫¶ */
        .voice-player { display: flex; align-items: center; gap: 10px; width: 100%; min-width: 120px; max-width: 220px; height: 32px; cursor: pointer; }
        .voice-btn { font-size: 22px; color: var(--text-main); display: flex; }
        .voice-track { flex: 1; height: 3px; background: rgba(0,0,0,0.1); border-radius: 2px; overflow: hidden; }
        .voice-progress { height: 100%; background: var(--text-main); width: 0%; }
        .voice-duration { font-size: 12px; color: var(--text-light); white-space: nowrap; }

        .msg-img { max-width: 100%; border-radius: 8px; display: block; }
        .msg-file { display: flex; align-items: center; gap: 8px; font-size: 14px; color: var(--text-main); text-decoration: none; }
        
        /* Áä∂ÊÄÅËÑöÊ†á (Â∑≤ËØªÂõûÊâß) */
        .msg-footer { display: flex; align-items: center; gap: 4px; margin-top: 2px; justify-content: flex-end; width: 100%; }
        .msg-time { font-size: 10px; opacity: 0.5; }
        .read-icon { font-size: 14px; line-height: 1; color: #999; }
        .read-icon.read { color: #34c759; } /* ÂØπÊñπÂ∑≤ËØªÂèòÁªø */

        /* ËæìÂÖ•Âå∫ */
        .chat-input-area { padding: 10px; border-top: 1px solid var(--border); background: rgba(253, 246, 227, 0.95); display: flex; gap: 8px; align-items: flex-end; min-height: 56px; }
        .toolbar-btn { background: transparent; border: none; color: var(--text-light); font-size: 22px; padding: 8px; transition: 0.2s; flex-shrink: 0; }
        .toolbar-btn:active { color: var(--text-main); }
        .toolbar-btn.recording { color: var(--danger); animation: pulse 1s infinite; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

        .input-box { flex: 1; border: 1px solid var(--border); background: #fff; padding: 10px 12px; border-radius: 18px; font-size: 15px; outline: none; height: 40px; margin-bottom: 5px; }
        .send-btn { background: var(--btn-primary); color: #fff; border: none; width: 40px; height: 40px; border-radius: 50%; font-size: 18px; margin-bottom: 5px; flex-shrink: 0; display: flex; align-items: center; justify-content: center; }

        /* ËØ≠Èü≥Á°ÆËÆ§Êù° */
        .voice-confirm-bar { flex: 1; display: flex; align-items: center; justify-content: space-between; background: #fff; border-radius: 18px; padding: 5px 15px; height: 44px; margin-bottom: 5px; border: 1px solid var(--border); }
        .voice-confirm-text { font-size: 13px; color: #666; }
        .vc-btn { font-size: 20px; padding: 5px; cursor: pointer; }
        .vc-play { color: var(--text-main); }
        .vc-cancel { color: var(--danger); }
        .vc-send { color: var(--success); }

        /* ÁßªÂä®Á´ØÈÄÇÈÖç */
        @media (max-width: 768px) {
            .sidebar { width: 100%; }
            .main-chat { position: fixed; top: 0; left: 0; width: 100%; height: 100%; transform: translateX(100%); transition: transform 0.25s ease-in-out; }
            .main-chat.active { transform: translateX(0); }
            .back-btn { display: block; }
            .sidebar.chat-open { display: none; } /* ÊÄßËÉΩ‰ºòÂåñ */
            .message-row { max-width: 85%; }
            .voice-player { max-width: 60vw; } /* ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÈôêÂà∂ËØ≠Èü≥Êù°ÂÆΩÂ∫¶ */
        }
        
        /* Ê®°ÊÄÅÊ°ÜÁ≠âÊ†∑Âºè‰øùÊåÅ‰∏çÂèò... */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(74, 59, 42, 0.4); backdrop-filter: blur(4px); display: flex; justify-content: center; align-items: center; z-index: 100; }
        .modal-card { background: #fffbf0; padding: 30px; width: 85%; max-width: 320px; border-radius: 16px; text-align: center; border: 1px solid var(--border); }
        .modal-input { width: 100%; padding: 12px; margin-bottom: 10px; border: 1px solid var(--border); border-radius: 8px; font-size: 15px; outline: none; }
        .modal-btn { width: 100%; padding: 12px; background: var(--btn-primary); color: #fff; border: none; border-radius: 8px; font-weight: bold; }
        .context-menu { position: fixed; background: #fff; border: 1px solid var(--border); border-radius: 8px; padding: 5px 0; z-index: 1000; min-width: 120px; box-shadow: 0 5px 15px rgba(0,0,0,0.1); }
        .menu-item { padding: 10px 15px; font-size: 14px; display: flex; gap: 8px; }
        .emoji-panel { position: absolute; bottom: 70px; left: 50%; transform: translateX(-50%); background: #fff; border: 1px solid var(--border); border-radius: 12px; width: 95%; max-width: 340px; height: 250px; z-index: 50; display: flex; flex-direction: column; }
        .emoji-content { flex: 1; overflow-y: auto; padding: 10px; display: grid; grid-template-columns: repeat(7, 1fr); gap: 5px; }
        .emoji-item { font-size: 24px; text-align: center; padding: 5px; }
    </style>
</head>
<body>

<div id="app" @click="handleClickOutside">
    <div class="context-menu" v-if="contextMenu.visible" :style="{ top: contextMenu.y + 'px', left: contextMenu.x + 'px' }" @click.stop>
        <div class="menu-item" v-if="canRecall" @click="recallMessage"><i class="bi bi-arrow-counterclockwise"></i> Êí§Âõû</div>
        <div class="menu-item" style="color:var(--danger)" @click="deleteMessage"><i class="bi bi-trash"></i> Âà†Èô§</div>
    </div>

    <div class="modal-overlay" v-if="!currentUser">
        <div class="modal-card">
            <h2 style="margin-bottom: 20px; color: var(--text-main);">11s Chat</h2>
            <input type="text" class="modal-input" v-model="loginForm.username" placeholder="Áî®Êà∑Âêç">
            <input type="password" class="modal-input" v-model="loginForm.password" placeholder="ÂØÜÁ†Å">
            <button class="modal-btn" @click="handleLogin">{{ isRegistering ? 'Ê≥®ÂÜå' : 'ÁôªÂΩï' }}</button>
            <div style="margin-top:15px; font-size:12px; color:#888;" @click="isRegistering = !isRegistering">{{ isRegistering ? 'ËøîÂõûÁôªÂΩï' : 'ÂàõÂª∫Ë¥¶Âè∑' }}</div>
            <div style="color:red; font-size:12px; margin-top:10px;">{{ errorMessage }}</div>
        </div>
    </div>

    <template v-if="currentUser">
        <div class="sidebar" :class="{ 'chat-open': currentChat }">
            <div class="brand">
                <span><i class="bi bi-feather"></i> 11s Chat</span>
                <span class="conn-status" :class="{ online: isConnected }"></span>
            </div>
            <div class="section-header">
                ËÅîÁ≥ª‰∫∫ <i class="bi bi-plus-circle-fill icon-btn" @click="addFriendPrompt"></i>
            </div>
            <div class="friend-list">
                <div v-for="friend in friends" :key="friend.id" class="friend-item" @click="selectChat(friend)">
                    <div class="avatar">{{ friend.username.substring(0,1) }}</div>
                    <div class="friend-info">
                        <div class="friend-name">{{ friend.username }}</div>
                        <div class="friend-preview">{{ getPreviewText(friend.lastMsg) }}</div>
                    </div>
                    <div class="unread-badge" v-if="friend.unread > 0">{{ friend.unread }}</div>
                </div>
            </div>
            <div class="user-panel">
                <div class="avatar" style="width:32px; height:32px; font-size:14px;">{{ currentUser.username.substring(0,1) }}</div>
                <div style="font-weight:bold;">{{ currentUser.username }}</div>
                <i class="bi bi-box-arrow-right action-icon" @click="logout"></i>
            </div>
        </div>

        <div class="main-chat" :class="{ active: currentChat }">
            <template v-if="currentChat">
                <div class="chat-header">
                    <i class="bi bi-chevron-left back-btn" @click="backToFriends"></i>
                    <span>{{ currentChat.username }}</span>
                </div>
                
                <div class="chat-messages" id="msg-container" @click="showEmoji = false">
                    <TransitionGroup name="msg-anim">
                        <div v-for="msg in messages" :key="msg.id" class="message-row" :class="msg.sender_id === currentUser.id ? 'sent' : 'received'">
                            <div class="message-bubble" 
                                 :class="[msg.sender_id === currentUser.id ? 'sent' : 'received', { recalled: msg.is_recalled }]"
                                 @contextmenu.prevent="showContextMenu($event, msg)"
                                 @click="handleMsgClick($event, msg)">
                                
                                <template v-if="msg.is_recalled">
                                    <i class="bi bi-arrow-counterclockwise"></i> Ê∂àÊÅØÂ∑≤Êí§Âõû
                                </template>
                                
                                <template v-else>
                                    <div v-if="msg.msg_type === 'text'">{{ msg.content }}</div>
                                    <img v-else-if="msg.msg_type === 'image'" :src="msg.file_url" class="msg-img">
                                    <div v-else-if="msg.msg_type === 'voice'" class="voice-player" @click.stop="toggleVoice(msg)">
                                        <div class="voice-btn"><i class="bi" :class="playingAudioId === msg.id ? 'bi-pause-fill' : 'bi-play-fill'"></i></div>
                                        <div class="voice-track"><div class="voice-progress" :style="{ width: (playingAudioId === msg.id ? playProgress : 0) + '%' }"></div></div>
                                        <div class="voice-duration">{{ msg.file_name?.replace(/[^\d]/g, '') || '' }}s</div>
                                    </div>
                                    
                                    <div class="msg-footer">
                                        <span class="msg-time">{{ formatTime(msg.created_at) }}</span>
                                        <i v-if="msg.sender_id === currentUser.id" class="bi read-icon" 
                                           :class="msg.is_read ? 'bi-check2-all read' : 'bi-check2'" 
                                           :title="msg.is_read ? 'Â∑≤ËØª' : 'Â∑≤ÂèëÈÄÅ'"></i>
                                    </div>
                                </template>
                            </div>
                        </div>
                    </TransitionGroup>
                </div>
                
                <div class="chat-input-area">
                    <button class="toolbar-btn" @click="triggerFileUpload"><i class="bi bi-paperclip"></i></button>
                    <input type="file" id="fileInput" style="display:none" @change="handleFileUpload">

                    <button class="toolbar-btn" :class="{ recording: isRecording }" 
                            @mousedown="startRecord" @mouseup="stopRecord" 
                            @touchstart.prevent="startRecord" @touchend.prevent="stopRecord">
                        <i class="bi bi-mic"></i>
                    </button>

                    <button class="toolbar-btn" @click.stop="showEmoji = !showEmoji"><i class="bi bi-emoji-smile"></i></button>
                    <div class="emoji-panel" v-if="showEmoji" @click.stop>
                        <div class="emoji-content">
                            <div class="emoji-item" v-for="em in EMOJIS" @click="addEmoji(em)">{{ em }}</div>
                        </div>
                    </div>

                    <template v-if="voiceReviewBlob">
                        <div class="voice-confirm-bar">
                            <span class="voice-confirm-text">ËØ≠Èü≥ÂæÖÂèëÈÄÅ</span>
                            <div style="display:flex; gap:10px;">
                                <i class="bi bi-play-circle-fill vc-btn vc-play" @click="playReviewVoice"></i>
                                <i class="bi bi-x-circle-fill vc-btn vc-cancel" @click="cancelVoice"></i>
                                <i class="bi bi-check-circle-fill vc-btn vc-send" @click="confirmSendVoice"></i>
                            </div>
                        </div>
                    </template>
                    <template v-else>
                        <input type="text" class="input-box" v-model="newMessage" placeholder="ÂÜô‰ø°..." @keyup.enter="sendMessage" @focus="markAsRead">
                        <button class="send-btn" @click="sendMessage"><i class="bi bi-send-fill"></i></button>
                    </template>
                </div>
            </template>
            <template v-else>
                <div class="empty-state d-none d-md-flex" style="flex:1; display:flex; align-items:center; justify-content:center; opacity:0.5;">
                    ÈÄâÊã©Â•ΩÂèã
                </div>
            </template>
        </div>
    </template>
</div>

<script>
    const SUPABASE_URL = 'https://fznfneqwxzuwtognuoeo.supabase.co'; 
    const SUPABASE_KEY = 'sb_publishable_UlNMDLt4OaYIX-_lCezGwA_8jIQLhFO'; 
    const sb = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
    const { createApp, ref, onMounted, nextTick, onUnmounted, computed } = Vue;

    const EMOJIS = ['üòÄ','üòÇ','ü•∞','üòé','ü§î','üò°','üò≠','üëç','ü§ù','üéâ','üî•','‚ù§Ô∏è','üìú','üñäÔ∏è','‚òï','üç∫','üçï','üê±','üê∂','üê∏','üëª','üëΩ','ü§ñ','üí©'];

    createApp({
        setup() {
            const currentUser = ref(null);
            const loginForm = ref({ username: '', password: '' });
            const isRegistering = ref(false);
            const isLoading = ref(false);
            const errorMessage = ref('');
            const friends = ref([]);
            const currentChat = ref(null);
            const messages = ref([]);
            const newMessage = ref('');
            const isConnected = ref(false);
            const showEmoji = ref(false);
            const contextMenu = ref({ visible: false, x: 0, y: 0, msg: null });
            
            // Audio
            const isRecording = ref(false);
            const voiceReviewBlob = ref(null); // ÂæÖÂèëÈÄÅÁöÑËØ≠Èü≥
            const playingAudioId = ref(null);
            const playProgress = ref(0);
            let mediaRecorder = null;
            let audioChunks = [];
            let currentAudioObj = null;
            let progressInterval = null;

            onMounted(() => {
                const saved = localStorage.getItem('11s_user');
                if (saved) { try { currentUser.value = JSON.parse(saved); loadFriends(); setupRealtime(); } catch(e) {} }
            });

            // ÁôªÂΩïÈÄªËæë
            const handleLogin = async () => {
                errorMessage.value = '';
                if(!loginForm.value.username) return;
                isLoading.value = true;
                const cleanName = loginForm.value.username.trim();
                const password = loginForm.value.password;
                try {
                    if (isRegistering.value) {
                        const { data: exist } = await sb.from('chat_users').select('id').eq('username', cleanName).maybeSingle();
                        if (exist) throw new Error("Áî®Êà∑Â∑≤Â≠òÂú®");
                        const { data: newUser, error } = await sb.from('chat_users').insert({ username: cleanName, password }).select().single();
                        if (error) throw error;
                        loginSuccess(newUser);
                    } else {
                        const { data: user, error } = await sb.from('chat_users').select('*').eq('username', cleanName).maybeSingle();
                        if (!user || user.password !== password) throw new Error("Â§±Ë¥•");
                        loginSuccess(user);
                    }
                } catch (e) { errorMessage.value = e.message; }
                isLoading.value = false;
            };

            const loginSuccess = (user) => {
                currentUser.value = user; localStorage.setItem('11s_user', JSON.stringify(user));
                loadFriends(); setupRealtime();
            };

            // Â•ΩÂèã & Ê∂àÊÅØ
            const loadFriends = async () => {
                const { data: f1 } = await sb.from('chat_friends').select('friend_id').eq('user_id', currentUser.value.id);
                const { data: f2 } = await sb.from('chat_friends').select('user_id').eq('friend_id', currentUser.value.id);
                const ids = [...new Set([...(f1||[]).map(f => f.friend_id), ...(f2||[]).map(f => f.user_id)])];
                if (ids.length > 0) {
                    const { data } = await sb.from('chat_users').select('*').in('id', ids);
                    // Fetch last msg for preview
                    const friendsWithData = await Promise.all(data.map(async u => {
                        const { data: last } = await sb.from('chat_messages').select('*').or(`sender_id.eq.${u.id},receiver_id.eq.${u.id}`).or(`sender_id.eq.${currentUser.value.id},receiver_id.eq.${currentUser.value.id}`).order('created_at', { ascending: false }).limit(1);
                        const { count } = await sb.from('chat_messages').select('*', { count: 'exact', head: true }).eq('sender_id', u.id).eq('receiver_id', currentUser.value.id).eq('is_read', false);
                        return { ...u, unread: count || 0, lastMsg: last?.[0] };
                    }));
                    friends.value = friendsWithData;
                }
            };

            const selectChat = async (friend) => {
                currentChat.value = friend;
                friend.unread = 0;
                await loadMessages();
                markAsRead();
                // Mobile: push view
                if(window.innerWidth <= 768) nextTick(() => document.querySelector('.main-chat').classList.add('active'));
            };

            const loadMessages = async () => {
                if (!currentChat.value) return;
                const { data } = await sb.from('chat_messages').select('*').or(`sender_id.eq.${currentUser.value.id},receiver_id.eq.${currentUser.value.id}`).order('created_at', { ascending: true });
                // Filter locally to ensure strict match
                messages.value = (data || []).filter(m => (m.sender_id === currentUser.value.id && m.receiver_id === currentChat.value.id) || (m.sender_id === currentChat.value.id && m.receiver_id === currentUser.value.id));
                scrollToBottom();
            };

            const sendMessage = async () => {
                if (!newMessage.value.trim() && !newMessage.value.startsWith('img::')) return;
                const content = newMessage.value; newMessage.value = ''; showEmoji.value = false;
                
                // Optimistic UI (Vue Transition handles animation)
                const tempMsg = { id: Date.now(), sender_id: currentUser.value.id, receiver_id: currentChat.value.id, content, msg_type: 'text', created_at: new Date().toISOString() };
                messages.value.push(tempMsg); scrollToBottom();
                
                await sb.from('chat_messages').insert({ sender_id: currentUser.value.id, receiver_id: currentChat.value.id, content, msg_type: 'text' });
            };

            // ËØ≠Èü≥ÈÄªËæë - Á°ÆËÆ§ÂèëÈÄÅÊ®°Âºè
            const startRecord = async () => {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];
                    mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
                    mediaRecorder.onstop = () => {
                        voiceReviewBlob.value = new Blob(audioChunks, { type: 'audio/webm' });
                    };
                    mediaRecorder.start();
                    isRecording.value = true;
                } catch(e) { alert("È∫¶ÂÖãÈ£éÊùÉÈôêË¢´ÊãíÁªù"); }
            };
            const stopRecord = () => {
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                    isRecording.value = false;
                }
            };
            const cancelVoice = () => { voiceReviewBlob.value = null; };
            const playReviewVoice = () => { if(voiceReviewBlob.value) new Audio(URL.createObjectURL(voiceReviewBlob.value)).play(); };
            const confirmSendVoice = async () => {
                if (!voiceReviewBlob.value) return;
                const blob = voiceReviewBlob.value;
                voiceReviewBlob.value = null; // Ê∏ÖÁ©∫ÂæÖÂèëÈÄÅ
                
                const duration = Math.ceil(blob.size / 5000); 
                const fileName = `voice_${Date.now()}.webm`;
                
                // Optimistic push
                const tempMsg = { id: Date.now(), sender_id: currentUser.value.id, receiver_id: currentChat.value.id, msg_type: 'voice', file_name: duration+'s', created_at: new Date().toISOString() };
                messages.value.push(tempMsg); scrollToBottom();

                const { error } = await sb.storage.from('chat-uploads').upload(fileName, blob);
                if(!error) {
                    const { data } = sb.storage.from('chat-uploads').getPublicUrl(fileName);
                    await sb.from('chat_messages').insert({ 
                        sender_id: currentUser.value.id, 
                        receiver_id: currentChat.value.id, 
                        msg_type: 'voice', 
                        file_url: data.publicUrl, 
                        file_name: duration + 's', 
                        content: '[ËØ≠Èü≥]' 
                    });
                }
            };
            
            // ËØ≠Èü≥Êí≠Êîæ
            const toggleVoice = (msg) => {
                if (playingAudioId.value === msg.id) { stopAudio(); return; }
                stopAudio();
                const audio = new Audio(msg.file_url);
                currentAudioObj = audio;
                playingAudioId.value = msg.id;
                audio.play();
                progressInterval = setInterval(() => { if(audio.duration) playProgress.value = (audio.currentTime / audio.duration) * 100; }, 100);
                audio.onended = stopAudio;
            };
            const stopAudio = () => {
                if (currentAudioObj) { currentAudioObj.pause(); currentAudioObj = null; }
                if (progressInterval) clearInterval(progressInterval);
                playingAudioId.value = null; playProgress.value = 0;
            };

            // ÂÆûÊó∂ÁõëÂê¨ (Realtime)
            const setupRealtime = () => {
                sb.removeAllChannels();
                sb.channel('public:chat_messages')
                .on('postgres_changes', { event: '*', schema: 'public', table: 'chat_messages' }, (payload) => {
                    const msg = payload.new;
                    if (payload.eventType === 'INSERT') {
                        // Â¶ÇÊûúÊòØÂΩìÂâçÂØπËØù
                        if (currentChat.value && ((msg.sender_id === currentUser.value.id && msg.receiver_id === currentChat.value.id) || (msg.sender_id === currentChat.value.id && msg.receiver_id === currentUser.value.id))) {
                            // ÂéªÈáç (‰πêËßÇÊõ¥Êñ∞IDÊòØÊó∂Èó¥Êà≥ÔºåDB IDÊòØintÔºåÂ¶ÇÊûúÊó∂Èó¥ÊûÅÁü≠ÂèØËÉΩ‰ºöÈáçÔºåÁÆÄÂçïÂéªÈáçÈù†IDÊòØÂê¶Â≠òÂú®)
                            // Êõ¥Â•ΩÁöÑÊñπÂºèÊòØÁúã created_at
                            if (!messages.value.some(m => m.id === msg.id)) {
                                messages.value.push(msg);
                                scrollToBottom();
                            }
                            // Â¶ÇÊûúÊòØÂØπÊñπÂèëÁöÑÔºåÁ´ãÂç≥Ê†áËÆ∞Â∑≤ËØª
                            if (msg.sender_id !== currentUser.value.id) markAsRead();
                        } else {
                            loadFriends(); // Êõ¥Êñ∞ÂàóË°®È¢ÑËßàÂíåÁ∫¢ÁÇπ
                        }
                    } 
                    else if (payload.eventType === 'UPDATE') {
                        // Â§ÑÁêÜÂ∑≤ËØªÂõûÊâßÊõ¥Êñ∞ / Êí§Âõû
                        const idx = messages.value.findIndex(m => m.id === msg.id);
                        if (idx !== -1) messages.value[idx] = msg;
                    }
                })
                .subscribe(s => isConnected.value = s === 'SUBSCRIBED');
            };

            // ÊùÇÈ°π
            const markAsRead = async () => { if(currentChat.value) await sb.from('chat_messages').update({ is_read: true }).eq('sender_id', currentChat.value.id).eq('receiver_id', currentUser.value.id).eq('is_read', false); };
            const triggerFileUpload = () => document.getElementById('fileInput').click();
            const handleFileUpload = async (e) => {
                const file = e.target.files[0]; if (!file) return;
                const type = file.type.startsWith('image/') ? 'image' : 'file';
                const fileName = `${Date.now()}_${file.name}`;
                // Optimistic...
                const { error } = await sb.storage.from('chat-uploads').upload(fileName, file);
                if(!error) {
                    const { data } = sb.storage.from('chat-uploads').getPublicUrl(fileName);
                    await sb.from('chat_messages').insert({ sender_id: currentUser.value.id, receiver_id: currentChat.value.id, msg_type: type, file_url: data.publicUrl, file_name: file.name, content: type==='image'?'[ÂõæÁâá]':'[Êñá‰ª∂]' });
                }
            };
            const addEmoji = (em) => newMessage.value += em;
            const logout = () => { localStorage.removeItem('11s_user'); location.reload(); };
            const scrollToBottom = () => nextTick(() => { const c = document.getElementById('msg-container'); if(c) c.scrollTop = c.scrollHeight + 100; });
            const formatTime = (iso) => { const d = new Date(iso); return `${d.getHours().toString().padStart(2,'0')}:${d.getMinutes().toString().padStart(2,'0')}`; };
            const backToFriends = () => { document.querySelector('.main-chat').classList.remove('active'); setTimeout(() => currentChat.value = null, 300); };
            const addFriendPrompt = async () => {
                const name = prompt("ËæìÂÖ•Â•ΩÂèãÁî®Êà∑Âêç"); if(!name) return;
                const { data } = await sb.from('chat_users').select('*').eq('username', name.trim()).maybeSingle();
                if(data) { await sb.from('chat_friends').insert({user_id:currentUser.value.id, friend_id:data.id}); alert("Ê∑ªÂä†ÊàêÂäü"); loadFriends(); }
            };
            const showContextMenu = (e, msg) => { if(msg.sender_id === currentUser.value.id && !msg.is_recalled) contextMenu.value = { visible: true, x: e.clientX, y: e.clientY, msg }; };
            const handleMsgClick = (e, msg) => { if (window.innerWidth <= 768 && msg.sender_id === currentUser.value.id) { e.preventDefault(); showContextMenu(e, msg); } };
            const handleClickOutside = () => { showEmoji.value = false; contextMenu.value.visible = false; };
            const recallMessage = async () => { await sb.from('chat_messages').update({ is_recalled: true }).eq('id', contextMenu.value.msg.id); contextMenu.value.visible = false; };
            const deleteMessage = () => { messages.value = messages.value.filter(m => m.id !== contextMenu.value.msg.id); contextMenu.value.visible = false; };
            const canRecall = computed(() => contextMenu.value.msg && ((new Date() - new Date(contextMenu.value.msg.created_at)) / 1000 / 60) < 2);
            const getPreviewText = (msg) => !msg ? '' : (msg.is_recalled ? 'Êí§Âõû‰∫Ü‰∏ÄÊù°Ê∂àÊÅØ' : (msg.msg_type==='text' ? msg.content : `[${msg.msg_type}]`));

            return {
                currentUser, loginForm, isRegistering, isLoading, errorMessage, friends, currentChat, messages, newMessage, isConnected, showEmoji, EMOJIS,
                contextMenu, canRecall, isRecording, playingAudioId, playProgress, voiceReviewBlob,
                handleLogin, logout, addFriendPrompt, selectChat, sendMessage, formatTime, addEmoji, triggerFileUpload, handleFileUpload,
                startRecord, stopRecord, confirmSendVoice, cancelVoice, playReviewVoice, toggleVoice,
                showContextMenu, recallMessage, deleteMessage, handleClickOutside, backToFriends, handleMsgClick, markAsRead, getPreviewText
            };
        }
    }).mount('#app');
</script>
</body>
</html>
